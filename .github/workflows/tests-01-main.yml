name: ðŸ“¦ Package Tests

on:
  pull_request:
    types: [opened, synchronize]
    paths:
      - "01-main/packages/*"
      - "01-main/manifest"
      - "!01-main/packages/*.html"
      - "!01-main/packages/*.json"
      - "!01-main/packages/timestamp"
  workflow_dispatch:
    inputs:
      packages:
        description: 'Space-separated list of packages to test (empty = all packages, random 256 if over limit)'
        required: false
        default: ''

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      has_packages: ${{ steps.detect.outputs.has_packages }}
      excluded_packages: ${{ steps.detect.outputs.excluded_packages }}
      has_excluded: ${{ steps.detect.outputs.has_excluded }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed packages
        id: detect
        run: |
          MAX_JOBS=256

          if [ -n "${{ github.event.pull_request.base.sha }}" ]; then
            # Pull request: detect changed package files
            CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep "^01-main/packages/" | sed "s|^01-main/packages/||" || true)
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # workflow_dispatch: use specified packages or read all from manifest
            INPUT_PACKAGES="${{ github.event.inputs.packages }}"
            if [ -n "${INPUT_PACKAGES}" ]; then
              CHANGED_FILES="${INPUT_PACKAGES}"
            else
              # Read all packages from manifest (skip first line which is repo URL)
              echo "::notice::No packages specified. Reading all packages from manifest."
              CHANGED_FILES=$(tail -n +2 01-main/manifest | tr '\n' ' ')
            fi
          else
            CHANGED_FILES=""
          fi

          # Filter out non-package files (html, json, timestamp)
          PACKAGES=""
          for FILE in ${CHANGED_FILES}; do
            case "${FILE}" in
              *.html|*.json|timestamp) continue ;;
              *) PACKAGES="${PACKAGES} ${FILE}" ;;
            esac
          done

          # Trim leading/trailing whitespace
          PACKAGES=$(echo "${PACKAGES}" | xargs)
          PACKAGE_COUNT=$(echo "${PACKAGES}" | wc -w)

          # Handle random selection if over limit
          EXCLUDED=""
          if [ "${PACKAGE_COUNT}" -gt "${MAX_JOBS}" ]; then
            echo "::warning::Package count (${PACKAGE_COUNT}) exceeds GitHub's ${MAX_JOBS} job limit. Randomly selecting ${MAX_JOBS} packages."

            # Shuffle and select MAX_JOBS packages
            SELECTED=$(echo "${PACKAGES}" | tr ' ' '\n' | shuf | head -n ${MAX_JOBS} | sort | tr '\n' ' ' | xargs)

            # Get excluded packages (those not selected)
            EXCLUDED=$(echo "${PACKAGES}" | tr ' ' '\n' | sort | grep -v -x -F -f <(echo "${SELECTED}" | tr ' ' '\n') | tr '\n' ' ' | xargs)

            PACKAGES="${SELECTED}"
            EXCLUDED_COUNT=$(echo "${EXCLUDED}" | wc -w)
            echo "::notice::Selected ${MAX_JOBS} packages for testing. ${EXCLUDED_COUNT} packages will not be tested."
          elif [ "${PACKAGE_COUNT}" -gt 200 ]; then
            echo "::warning::${PACKAGE_COUNT} packages specified. Approaching GitHub's ${MAX_JOBS} job limit."
          fi

          # Convert to JSON arrays and set outputs
          if [ -n "${PACKAGES}" ]; then
            JSON_ARRAY=$(echo "${PACKAGES}" | tr ' ' '\n' | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "packages=${JSON_ARRAY}" >> $GITHUB_OUTPUT
            echo "has_packages=true" >> $GITHUB_OUTPUT
            echo "Detected packages: ${JSON_ARRAY}"
          else
            echo "packages=[]" >> $GITHUB_OUTPUT
            echo "has_packages=false" >> $GITHUB_OUTPUT
            echo "No packages to test"
          fi

          if [ -n "${EXCLUDED}" ]; then
            EXCLUDED_JSON=$(echo "${EXCLUDED}" | tr ' ' '\n' | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "excluded_packages=${EXCLUDED_JSON}" >> $GITHUB_OUTPUT
            echo "has_excluded=true" >> $GITHUB_OUTPUT
            echo "Excluded packages: ${EXCLUDED_JSON}"
          else
            echo "excluded_packages=[]" >> $GITHUB_OUTPUT
            echo "has_excluded=false" >> $GITHUB_OUTPUT
          fi

  test-package:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_packages == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJSON(needs.detect-changes.outputs.packages) }}
    continue-on-error: true

    env:
      DEBIAN_FRONTEND: noninteractive
      DEBGET_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install apt apt-transport-https bash coreutils curl dpkg gpg grep libc-bin lsb-release sed software-properties-common sudo wget desktop-file-utils -y

      - name: Initialize /etc/deb-get
        run: |
          sudo mkdir /etc/deb-get
          echo "deb-get 1 github" | sudo tee /etc/deb-get/installed > /dev/null
          sudo cp ./01-main/manifest /etc/deb-get/01-main.repo
          sudo cp -r ./01-main/packages /etc/deb-get/01-main.d
          sudo gpg -k > /dev/null

      - name: Test package ${{ matrix.package }}
        id: test
        run: |
          chmod a+x ./deb-get
          set -x

          APP="${{ matrix.package }}"
          START_TIME=$(date +%s)
          STATUS="pass"
          ERROR_MSG=""

          SUPPORTED=$(./deb-get list --raw)
          if echo "${SUPPORTED}" | grep -q -m 1 "^${APP}$"; then
            ./deb-get install "${APP}" || { STATUS="fail"; ERROR_MSG="Installation failed"; }

            if [ "${STATUS}" = "pass" ]; then
              if ./deb-get show "${APP}" | grep -q "Installed:	No"; then
                STATUS="fail"
                ERROR_MSG="Failed to detect ${APP} as installed"
              else
                PUBLISHED_VER=$(./deb-get show "${APP}" | grep "Published:" | grep -oE '[^[:space:]]+$' || :)
                INSTALLED_VER=$(dpkg-query -Wf '${Version}' "${APP}" || :)
                if [ -n "${PUBLISHED_VER// /}" ] && dpkg --compare-versions "${PUBLISHED_VER}" gt "${INSTALLED_VER}"; then
                  STATUS="fail"
                  ERROR_MSG="Version mismatch: Published=${PUBLISHED_VER} Installed=${INSTALLED_VER}"
                else
                  ./deb-get purge "${APP}" || { STATUS="fail"; ERROR_MSG="Purge failed"; }
                fi
              fi
            fi
          else
            STATUS="skip"
            ERROR_MSG="Package not in supported list"
          fi

          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))

          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "duration=${DURATION}" >> $GITHUB_OUTPUT
          echo "error_msg=${ERROR_MSG}" >> $GITHUB_OUTPUT

          # Fail the step if test failed
          if [ "${STATUS}" = "fail" ]; then
            echo "::error::${ERROR_MSG}"
            exit 1
          fi

      - name: Save result
        if: always()
        run: |
          mkdir -p results
          cat > results/${{ matrix.package }}.json << EOF
          {
            "package": "${{ matrix.package }}",
            "status": "${{ steps.test.outputs.status || 'fail' }}",
            "duration": ${{ steps.test.outputs.duration || 0 }},
            "error": "${{ steps.test.outputs.error_msg || 'Unknown error' }}"
          }
          EOF

      - name: Upload result
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ matrix.package }}
          path: results/${{ matrix.package }}.json
          retention-days: 1

  report-results:
    needs: [detect-changes, test-package]
    if: always() && needs.detect-changes.outputs.has_packages == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Download all results
        uses: actions/download-artifact@v4
        with:
          pattern: result-*
          path: results
          merge-multiple: true

      - name: Generate summary
        env:
          EXCLUDED_PACKAGES: ${{ needs.detect-changes.outputs.excluded_packages }}
          HAS_EXCLUDED: ${{ needs.detect-changes.outputs.has_excluded }}
        run: |
          PASSED=0
          FAILED=0
          SKIPPED=0
          NOT_TESTED=0

          echo "## Package Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Status | Duration |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|----------|" >> $GITHUB_STEP_SUMMARY

          for FILE in results/*.json; do
            if [ -f "${FILE}" ]; then
              PACKAGE=$(jq -r '.package' "${FILE}")
              STATUS=$(jq -r '.status' "${FILE}")
              DURATION=$(jq -r '.duration' "${FILE}")
              ERROR=$(jq -r '.error' "${FILE}")

              case "${STATUS}" in
                pass)
                  ICON="âœ… pass"
                  PASSED=$((PASSED + 1))
                  ;;
                skip)
                  ICON="â­ï¸ skip"
                  SKIPPED=$((SKIPPED + 1))
                  ;;
                *)
                  ICON="âŒ fail"
                  FAILED=$((FAILED + 1))
                  ;;
              esac

              echo "| ${PACKAGE} | ${ICON} | ${DURATION}s |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          # Add excluded packages section if any were excluded
          if [ "${HAS_EXCLUDED}" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Not Tested (exceeded 256 job limit)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Package | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY

            # Parse excluded packages JSON array
            for PKG in $(echo "${EXCLUDED_PACKAGES}" | jq -r '.[]'); do
              echo "| ${PKG} | â­ï¸ not tested |" >> $GITHUB_STEP_SUMMARY
              NOT_TESTED=$((NOT_TESTED + 1))
            done
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Passed:** ${PASSED}" >> $GITHUB_STEP_SUMMARY
          echo "- **Failed:** ${FAILED}" >> $GITHUB_STEP_SUMMARY
          echo "- **Skipped:** ${SKIPPED}" >> $GITHUB_STEP_SUMMARY
          if [ "${NOT_TESTED}" -gt 0 ]; then
            echo "- **Not Tested:** ${NOT_TESTED}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Total:** $((PASSED + FAILED + SKIPPED + NOT_TESTED))" >> $GITHUB_STEP_SUMMARY

          # Exit with failure if any package failed
          if [ "${FAILED}" -gt 0 ]; then
            echo "::error::${FAILED} package(s) failed testing"
            exit 1
          fi
